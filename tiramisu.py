from tokenize import tokenize, untokenize, NAME
from io import BytesIO
from sys import argv

# Словарь перевода (алиасы)
VOCABULARY = {
    # ---------------------------------------------------------
    # Струкртура и функции
    # ---------------------------------------------------------
    'pie': 'class',  # Класс - это один большой пиорг
    'recipe': 'def',  # Что нужно по рецепту для блюда (входные данные), то и получаешь (результат функции)
    'from_bakery': 'from',  # Из какой пекарни
    'order': 'import',  # Заказать ингредиенты
    'serve': 'return',  # Вернуть значение = подать блюдо
    'portion': 'yield',  # Выдавать порционно
    'TOPPING': '@',  # Топпинг - как украшение блюда (декоратор)
    'chill': 'pass',  # Остыть/отдохнуть, ничего не делать
    'pastry': 'object',  # Базовый объект = заготовочное тесто для всего
    'muffin': 'lambda',  # Маффин - "мини-кекс", лямбда - "мини-функция"

    # ---------------------------------------------------------
    # Логика и условия
    # ---------------------------------------------------------
    'taste': 'if',  # Пробуем: если вкусно - выполняем
    'relish': 'elif',  # Если не вкусно, но всё же съедобно - пробуем дальше
    'dip': 'in',  # Макать в соус (условия в циклах и вхождение в список/строку)
    'sour': 'not',  # Отрицание (кисло)
    'aftertaste': 'else',  # Послевкусие, если основные условия не подошли
    'waffle': 'assert',  # Если условие "вафельное"/хрупкое
    'blend': 'and',  # Смешать два ингредиента (условия)

    # ---------------------------------------------------------
    # Циклы
    # ---------------------------------------------------------
    'chew': 'while',  # Пока жуём/условие верно - цикл идет
    'treat': 'for',  # Для каждого "угощения" в списке (to treat)
    'crack': 'break',  # Разбить (как яйцо) = прервать цикл
    'sprinkle': 'continue',  # Посыпать и идти дальше к следующей итерации
    'eat': 'del',  # Съесть = удалить объект

    # ---------------------------------------------------------
    # Типы данных и значения
    # ---------------------------------------------------------
    'candy': 'int',  # Целые числа - конфетки
    'syrup': 'float',  # Числа с плавающей точкой - текучие
    'licorice': 'str',  # Строки - длинные/тянутся, как лакричные палочки
    'Yummy': 'True',  # Вкусно = истина
    'Bitter': 'False',  # Не вкусно/горько = ложь
    'Crumbs': 'None',  # "Ничего не осталось, только крошки"
    'biscuit': 'bytes',  # Содержимое сухое и сжатое, как печенье

    # ---------------------------------------------------------
    # Коллекции
    # ---------------------------------------------------------
    'menu': 'dict',  # Меню блюд: название блюда - описание

    # ---------------------------------------------------------
    # Ошибки и исключения
    # ---------------------------------------------------------
    'cook': 'try',  # Попробовать приготовить
    'burnt': 'except',  # Если сгорело (ошибка)
    'dessert': 'finally',  # Десерт всегда подаётся в самом конце
    'complain': 'raise',  # Пожаловаться на плохое блюдо/подачу/т.д.

    # ---------------------------------------------------------
    # Встроенные функции
    # ---------------------------------------------------------
    'bake': 'print',  # Выпечь = вывести
    'flavour': 'type',  # Узнать, что это за "вкус" (тип объекта)
    'sift': 'filter',  # Просеять через сито (фильтрация)
    'sweetest': 'max',  # Найти самое большое (самое сладкое)
    'bitterest': 'min',  # Найти самое маленькое (самое горькое)
    'calories': 'len',  # Калорийность (длина)
    'scoop': 'round',   # Сформировать шарик (округлить число)
    'glaze': 'map',  # Покрыть каждое изделие глазурью/применить функцию к каждому элементу
}


def translate_tiramisu(code_string: str) -> str:
    """
    Переводит код Tiramisu в валидный Python код, используя токенизацию.
    :param code_string: Строка с кодом на Tiramisu
    :return: Строка с кодом на Python
    """
    tokens = tokenize(BytesIO(code_string.encode('utf-8')).readline)
    result = []

    for token in tokens:
        token_type = token.type
        token_string = token.string

        # Замена только имён (переменных, ключевых слов), а не строк
        if token_type == NAME and token_string in VOCABULARY:
            result.append((token_type, VOCABULARY[token_string]))
        else:
            result.append((token_type, token_string))

    return untokenize(result).decode('utf-8')


def run_file(filename: str) -> None:
    """
    Запускает файл с кодом на Tiramisu.
    :param filename: Имя файла с кодом на Tiramisu
    """
    with open(filename, 'r', encoding='utf-8') as file:
        source_code = file.read()

    python_code = translate_tiramisu(source_code)

    try:
        exec(python_code)
    except Exception as e:
        print(f"Tiramisu compiling error: {e}")


if __name__ == '__main__':
    if len(argv) < 2:
        print("Usage: python tiramisu.py <filename.tira>")
    else:
        run_file(argv[1])
